## 個人的に必要な用語

- 述語論理
- 集合
- 元
- 半群
- モノイド
- 群
- 可換群、アーベル群
- 環
- 閉じている
- 線形性
- 空間計算量

### 使用例

- max は半群だから操作の取り消しができない
- 自然数は加法について閉じている
- セグ木に乗せるために、半群に単位元を定義してモノイドにする
- セグ木のモノイドの空間計算量はO(N)

### 変数名の意味

- `suf`：suffix。後ろから累積和を取ったもの

## Tips

### multisetの要素の削除

`ms.erase(1)`だと複数の要素が一括で削除される。  
`ms.erase(ms.find(1))`であれば一つの要素だけが削除される。

### 最も簡単な暗号化と復号化

`~`を使う。  
非負整数を暗号化するときに`~v`と書き、複合化するときに`~(~v)`と書く。  
暗号化されているかどうかは`v<0`で判定できる。

### 相反する二つの操作を一つの関数にまとめる

空の多重集合があり、ここに整数を追加したり削除したりする。  
たまに「今何種類の整数があるか」というクエリが飛んでくる。  
このようなときに次の関数を用意する。

```cpp
map<int, int> mp;

auto operate = [&](int x, int d) {
  mp[x] += d;
  if (mp[x] == 0) mp.erase(x);
};
```

すると、追加と削除の操作をそれぞれ次のように書ける。

```cpp
operate(100, 1);
operate(100, -1);
```

この実装パターンは、相反する二つの操作を一箇所にまとめられる点で優れている。  
上の例のような単純な操作であれば恩恵は少ないが、操作が複雑になるにつれて恩恵が増していく。  

### 完全二分木

完全二分木の区間更新と一点取得は次のようにシンプルに実装できる。

<details>

```cpp
auto update = [&](int l, int r, int x) {
  l += N, r += N;
  while (l != r) {
    if (l & 1) operate(l++, x);
    if (r & 1) operate(--r, x);
    l /= 2, r /= 2;
  }
};

auto get = [&](int i) {
  i += N;
  /* 単位元で初期化した変数を用意 */
  while (i) {
    /* 二項演算の結果で変数を更新 */
    i /= 2;
  }
  return ret;
};
```
</details>

### $n$ 人を区別のない $k$ 個以下のグループに分ける場合の数（ベル数）

|人数|場合の数|
|-|-|
|1|1|
|2|2|
|3|5|
|4|15|
|5|52|
|6|203|
|7|877|
|8|4,140|
|9|21,147|
|10|115,975|
|11|678,570|
|12|4,213,597|
|13|27,644,437|
|14|190,899,322|
|15|1,382,958,545|

<details>
<summary>自然とベル数になる全探索のコード</summary>

```cpp
const int N = 10;
int cnt = 0;

vector<vector<int>> v;
auto rec = [&](auto rec, int x) -> void {
  if (x == N) {
    cnt++;
    return;
  }
  for (int i = 0; i < v.size(); i++) {
    v[i].push_back(x);
    rec(rec, x + 1);
    v[i].pop_back();
  }
  v.push_back({x});
  rec(rec, x + 1);
  v.pop_back();
};
rec(rec, 0);

cout << cnt << endl; //=> 115975
```
</details>

## ビット操作

|関数|説明|
|-|-|
|`__builtin_popcount`|ビットの 1 の数を返す|
|`bit_width`|整数のビット幅を返す。引数はunsigned|

## ビット集合の部分集合の列挙

```cpp
// 昇順
for (int t = 0;; t = (t - s) & s) {
  if (t == s) break;
}

// 降順
for (int t = s;; t = (t - 1) & s) {
  if (t == 0) break;
}
```
